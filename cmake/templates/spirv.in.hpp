/*!
 * \file @FILENAME_HPP@
 * \brief \b Classes: \a @CLASSNAME@
 * \warning This file was automatically generated by createSPIRV!
 */

#pragma once

#include "defines.hpp"
#include "rShaderBase.hpp"

namespace e_engine {

class iInit;
class rWorld;

class @CLASSNAME@ : public rShaderBase {
 private:
   static const std::vector<unsigned char> vRawData_vert;
   static const std::vector<unsigned char> vRawData_tesc;
   static const std::vector<unsigned char> vRawData_tese;
   static const std::vector<unsigned char> vRawData_geom;
   static const std::vector<unsigned char> vRawData_frag;
   static const std::vector<unsigned char> vRawData_comp;

 public:
   virtual bool has_vert() const { return @HAS_VERT@; }
   virtual bool has_tesc() const { return @HAS_TESC@; }
   virtual bool has_tese() const { return @HAS_TESE@; }
   virtual bool has_geom() const { return @HAS_GEOM@; }
   virtual bool has_frag() const { return @HAS_FRAG@; }
   virtual bool has_comp() const { return @HAS_COMP@; }

   virtual ShaderInfo getInfo_vert() const {
      return {
         { // Input
@INPUT_VERT@
         },
         { // Output
@OUTPUT_VERT@
         },
         { // Uniforms
@UNIFORM_VERT@
         },
         { // Uniform Blocks
@UNIFORM_B_VERT@
         }
      };
   }

   virtual ShaderInfo getInfo_tesc() const {
      return {
         { // Input
@INPUT_TESC@
         },
         { // Output
@OUTPUT_TESC@
         },
         { // Uniforms
@UNIFORM_TESC@
         },
         { // Uniform Blocks
@UNIFORM_B_TESC@
         }
      };
   }

   virtual ShaderInfo getInfo_tese() const {
      return {
         { // Input
@INPUT_TESE@
         },
         { // Output
@OUTPUT_TESE@
         },
         { // Uniforms
@UNIFORM_TESE@
         },
         { // Uniform Blocks
@UNIFORM_B_TESE@
         }
      };
   }

   virtual ShaderInfo getInfo_geom() const {
      return {
         { // Input
@INPUT_GEOM@
         },
         { // Output
@OUTPUT_GEOM@
         },
         { // Uniforms
@UNIFORM_GEOM@
         },
         { // Uniform Blocks
@UNIFORM_B_GEOM@
         }
      };
   }

   virtual ShaderInfo getInfo_frag() const {
      return {
         { // Input
@INPUT_FRAG@
         },
         { // Output
@OUTPUT_FRAG@
         },
         { // Uniforms
@UNIFORM_FRAG@
         },
         { // Uniform Blocks
@UNIFORM_B_FRAG@
         }
      };
   }

   virtual ShaderInfo getInfo_comp() const {
      return {
         { // Input
@INPUT_COMP@
         },
         { // Output
@OUTPUT_COMP@
         },
         { // Uniforms
@UNIFORM_COMP@
         },
         { // Uniform Blocks
@UNIFORM_B_COMP@
         }
      };
   }


   @CLASSNAME@() = delete;
   @CLASSNAME@( VkDevice _device )   : rShaderBase( _device )    {}
   @CLASSNAME@( iInit *_tempInit )   : rShaderBase( _tempInit )  {}
   @CLASSNAME@( rWorld *_tempWorld ) : rShaderBase( _tempWorld ) {}

   virtual std::vector<unsigned char> getRawData_vert() const;
   virtual std::vector<unsigned char> getRawData_tesc() const;
   virtual std::vector<unsigned char> getRawData_tese() const;
   virtual std::vector<unsigned char> getRawData_geom() const;
   virtual std::vector<unsigned char> getRawData_frag() const;
   virtual std::vector<unsigned char> getRawData_comp() const;
};

}
